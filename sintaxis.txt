Las comillas dobles pueden encerrar dentro una variable ($x) y la detecta. Las comillas simples no.

var_dump() Funcion que vuelca una varaible a la salida.
intdiv($x, $y) Funcion para dividir y devolver un entero siempre.

gettype() Funcion que devuelve una cadena con el tipo de la varaible.

Existe el tipo NULL cuyo unico valor posible es null.

El valor false se convierte en cadena vacia si se vuelca a la salida con un echo (conversión implicíta en string)
El valor true se convierte en 1 si se vuelca a la salida con un echo (conversión implicíta en string)

isset() Es una "funcion" que te devuelve true si la variable que le indicas existe y está asignada (es decir, que tiene un valor distinto de null). Una variable existente que vale null daria false con esta funcion.
is_null() Es una funcion que te devuelve true o false dependiendo de si el valor de la variable es null.

$x <=> $y   Este operador devuelve -1, 0 o 1 dependiendo de que si $x es menor, igual o mayor que $y




"25" == 25   Aqui el string se convierten en int y luego se comparan y se devuelve true

"250" < "27"  Si esta comparacion se hiciese entre cadenas daria false, pero php las convierte en int y luego las compara, así que da false.

=== devuelve true si los valores son iguales y además del mismo tipo

empty() Devuelve true si la variable es null, 0, "", "0"  Esta funcion puede causar problemas, por ejemplo en un formulario, ya que no es lo mismo dejar un campo vacio a que el usuario escriba un 0
Cuidado con la funcion empty porque si contiene un 0, tambien la da por vacia.

Operador fusion de null:    ??      Es el coalesce del sql, sustituye null por otro valor   $x ?? $y    devuelve $x si no es null, y $y si $x es null

Operador ternario:        $a ? $b : $c     Si $a es true, entonces devuelve $b, y si $a es false, entonces devuelve $c 

$a ?: $b   Operador Elvis

$x[2] accedes a caracter tercero de la cadena, es una indexación. Pero cuidado porque las letras con acento y otros caracteres ocupan de 2bytes, así que esto nunca lo usaremos.

Manipulacion de cadenas multibyte:
mb_substr($x, 2, 1)
Lo mismo pasa con el strlen y el mb_strlen

Arrays numericos:
Tradicionalmente la funcion array() crea un array con los argumentos que le metas:   $a = array('a', 'b', 'c')
Forma más moderna:  $a = ['a', 'b', 'c']
Añadir elemento por el final: $a[] = 'd'


Arrays asociativos:
$a = ['gato' => 'cat', 'perro' => 'dog']

Añadir elemento:
$a[caballo] = 'horse'

Eliminar elemento:
unset($a['perro'])

in_array($x, $y)  La funcion busca el valor $x en el array $y.

count() La funcion cuenta el numero de elementos que contiene el array

foreach ($array as $key => $value) {}
foreach ($array as $value) {}     Indicar $key es opcional

Sintaxis alternativa:
foreach ():
    ...
endforeach;

Si una variable de fuera de una funcion la declaras como global dentro de la propia funcion (global $x;), puedes usarla dentro de dicha funcion sin necesidad de pasarsela como argumento.

require 'auxiliar.php';  Este comando importa el contenido del archivo auxiliar.php al archivo actual (que se encuentra en el mismo directorio), es decir, sirve para importar funciones, objetos, variables...


Si pasas un array como parámetro a una función, en realidad solo le estás pasando una copia del array, por lo que la función no puede modificar el original.
Para pasar el array como referencia en una funcion se debe escribir &$array, de este modo, la función puede modificar el array original.

Lo mismo ocurre con las asignaciones...

Si hago esto: $y = $x      =>  En $y se crea una variable que contiene una copia del array $x. Es decir, son arrays diferentes.

Si hago esto: $y =& $x     =>  $y contiene la variable que apunta al mismo valor que $x (es decir, es la misma variable que $x). Es decir que si luego igualas $y a otra cosa, $x también contiene esa otra cosa. Son la misma variable.
                               Dicho de otra forma $x y $y son dos nombres que puede usarse por igual para hacer referencia a la unica variable que existe.

 
<?php declare(strict_types=1) ?>  Si añades esta linea al principio del archivo, haces que el codigo de php se vuelva estricto con los tipos de variables.


unset()  elimina una variable, array, objeto, propiedad, etc

